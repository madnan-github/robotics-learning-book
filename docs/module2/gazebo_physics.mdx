---
sidebar_position: 2
title: "Gazebo Physics Simulation"
---

# Gazebo Physics Simulation

In this section, we'll explore Gazebo, a physics-based simulation environment that provides accurate modeling of robot dynamics, collisions, and environmental interactions.

## Setting Up Gazebo with ROS 2

Gazebo integrates seamlessly with ROS 2 through the `ros_gz` bridge packages. Let's start by launching a basic simulation:

```bash
# Launch a simple world with a robot
ros2 launch gazebo_ros empty_world.launch.py
```

## Spawning a Humanoid Robot

To work with humanoid robots, we'll spawn a model into the simulation:

```python
# Python script to spawn a humanoid robot
import rclpy
from gazebo_msgs.srv import SpawnEntity
from rclpy.node import Node

class RobotSpawner(Node):
    def __init__(self):
        super().__init__('robot_spawner')
        self.cli = self.create_client(SpawnEntity, '/spawn_entity')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Service not available, waiting again...')

    def spawn_robot(self, robot_name, robot_xml, initial_pose):
        req = SpawnEntity.Request()
        req.name = robot_name
        req.xml = robot_xml
        req.initial_pose = initial_pose
        future = self.cli.call_async(req)
        rclpy.spin_until_future_complete(self, future)
        return future.result()

def main():
    rclpy.init()
    spawner = RobotSpawner()

    # Load your humanoid robot URDF
    with open('path/to/humanoid.urdf', 'r') as f:
        robot_xml = f.read()

    # Define initial pose
    from geometry_msgs.msg import Pose
    initial_pose = Pose()
    initial_pose.position.x = 0.0
    initial_pose.position.y = 0.0
    initial_pose.position.z = 1.0

    result = spawner.spawn_robot('humanoid_robot', robot_xml, initial_pose)
    print(f'Spawn result: {result}')

    spawner.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Configuring Physics Parameters

Gazebo allows fine-tuning of physics parameters to match real-world behavior:

```xml
<!-- In your world file -->
<sdf version="1.7">
  <world name="default">
    <physics type="ode">
      <gravity>0 0 -9.8</gravity>
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1.0</real_time_factor>
      <real_time_update_rate>1000</real_time_update_rate>
      <ode>
        <solver>
          <type>quick</type>
          <iters>10</iters>
          <sor>1.0</sor>
        </solver>
        <constraints>
          <cfm>0.0</cfm>
          <erp>0.2</erp>
          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>
          <contact_surface_layer>0.001</contact_surface_layer>
        </constraints>
      </ode>
    </physics>
  </world>
</sdf>
```

## Adding Objects to the Environment

You can add objects to create more complex simulation scenarios:

```bash
# Add a simple box to the simulation
gz model -f /usr/share/gazebo-11/models/box.sdf -m box1 -x 1.0 -y 1.0 -z 0.5
```

## Understanding Gravity and Collision Parameters

Physics accuracy in simulation is crucial for transfer to real robots:

- **Gravity**: Should match Earth's gravity (9.8 m/sÂ²) for accurate simulation
- **Collision Detection**: Determines how objects interact physically
- **Friction**: Affects how objects slide against each other
- **Damping**: Controls energy loss in joints and motion

## Best Practices

1. Start with simple worlds and gradually add complexity
2. Validate physics parameters against real-world measurements
3. Use appropriate time steps for stable simulation
4. Test both forward and inverse dynamics