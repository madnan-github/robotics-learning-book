---
title: rclpy - Bridging Python Agents to ROS
sidebar_position: 3
---

# rclpy - Bridging Python Agents to ROS

## Learning Outcomes

After completing this section, you will be able to:
1. Create a simple ROS 2 publisher node using rclpy
2. Create a simple ROS 2 subscriber node using rclpy
3. Implement a publisher that simulates sensor data
4. Implement a subscriber that processes control commands
5. Understand the structure and components of ROS 2 Python nodes

## Introduction

In this section, we'll explore how to bridge Python agents to ROS 2 using the `rclpy` library, which is the official Python client library for ROS 2. This library allows Python programs to interact with the ROS 2 ecosystem, enabling communication between software agents and physical (or simulated) hardware components.

## Understanding rclpy

`rclpy` is the Python client library for ROS 2. It provides a Python API to interact with ROS 2 concepts like nodes, topics, services, parameters, and actions. It's built on top of the ROS 2 client library (rcl) and provides a Pythonic interface to ROS 2 functionality.

### Key Components of rclpy:

1. **Node**: The basic execution unit in ROS 2
2. **Publisher**: Sends messages to topics
3. **Subscriber**: Receives messages from topics
4. **Service Server**: Provides services
5. **Service Client**: Calls services
6. **Timer**: Executes callbacks at regular intervals

## Creating a Publisher Node

Let's start by creating a simple publisher node that simulates sensor data:

```python
# publisher_node.py
import rclpy
from rclpy.node import Node
from std_msgs.msg import Float32
import random


class SensorPublisher(Node):
    """
    A publisher node that simulates sensor data.

    This node publishes simulated sensor readings to a topic.
    In a real-world scenario, this could be data from an actual sensor.
    """

    def __init__(self):
        """Initialize the sensor publisher node."""
        super().__init__('sensor_publisher')

        # Create a publisher for sensor data
        self.publisher_ = self.create_publisher(Float32, 'sensor_data', 10)

        # Create a timer to publish data at regular intervals
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)

        # Counter for tracking published messages
        self.i = 0

        # Log that the node has started
        self.get_logger().info('Sensor publisher node initialized')

    def timer_callback(self):
        """Callback function that runs when the timer ticks."""
        # Create a message with simulated sensor data
        msg = Float32()
        # Simulate sensor reading with some random variation
        msg.data = 25.0 + random.uniform(-2.0, 2.0)  # Temperature in Celsius

        # Publish the message
        self.publisher_.publish(msg)

        # Log the published data
        self.get_logger().info(f'Publishing sensor data: {msg.data:.2f}')

        # Increment the counter
        self.i += 1


def main(args=None):
    """Main function to run the publisher node."""
    # Initialize rclpy
    rclpy.init(args=args)

    # Create the publisher node
    sensor_publisher = SensorPublisher()

    # Run the node until interrupted
    try:
        rclpy.spin(sensor_publisher)
    except KeyboardInterrupt:
        pass
    finally:
        # Clean up
        sensor_publisher.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

## Creating a Subscriber Node

Now let's create a subscriber node that processes control commands:

```python
# subscriber_node.py
import rclpy
from rclpy.node import Node
from std_msgs.msg import String


class CommandSubscriber(Node):
    """
    A subscriber node that processes control commands.

    This node subscribes to a command topic and processes incoming commands.
    """

    def __init__(self):
        """Initialize the command subscriber node."""
        super().__init__('command_subscriber')

        # Create a subscription to the command topic
        self.subscription = self.create_subscription(
            String,
            'control_commands',
            self.command_callback,
            10)

        # Make sure the subscription is properly set up
        self.subscription  # prevent unused variable warning

        # Log that the node has started
        self.get_logger().info('Command subscriber node initialized')

    def command_callback(self, msg):
        """
        Callback function that runs when a command is received.

        Args:
            msg: The received message containing the command
        """
        # Log the received command
        self.get_logger().info(f'Received command: {msg.data}')

        # Process the command (in this example, just log it)
        command = msg.data.lower()

        if command == 'start':
            self.get_logger().info('Processing START command')
            # Add actual start logic here
        elif command == 'stop':
            self.get_logger().info('Processing STOP command')
            # Add actual stop logic here
        elif command == 'reset':
            self.get_logger().info('Processing RESET command')
            # Add actual reset logic here
        else:
            self.get_logger().info(f'Unknown command: {command}')


def main(args=None):
    """Main function to run the subscriber node."""
    # Initialize rclpy
    rclpy.init(args=args)

    # Create the subscriber node
    command_subscriber = CommandSubscriber()

    # Run the node until interrupted
    try:
        rclpy.spin(command_subscriber)
    except KeyboardInterrupt:
        pass
    finally:
        # Clean up
        command_subscriber.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

## Complete Publisher-Subscriber Example

Here's a more comprehensive example that combines both publisher and subscriber functionality in a single node:

```python
# agent_bridge.py
import rclpy
from rclpy.node import Node
from std_msgs.msg import Float32, String
import random
import time


class AgentBridge(Node):
    """
    A Python agent that bridges to ROS 2.

    This node demonstrates both publishing sensor data and subscribing to commands,
    showing how a Python agent can interact with the ROS 2 ecosystem.
    """

    def __init__(self):
        """Initialize the agent bridge node."""
        super().__init__('agent_bridge')

        # Create publisher for sensor data
        self.sensor_publisher = self.create_publisher(Float32, 'sensor_data', 10)

        # Create subscription for control commands
        self.command_subscription = self.create_subscription(
            String,
            'control_commands',
            self.command_callback,
            10)

        # Create a timer for publishing sensor data
        timer_period = 1.0  # seconds
        self.timer = self.create_timer(timer_period, self.publish_sensor_data)

        # Counter for tracking published messages
        self.i = 0

        # Log that the node has started
        self.get_logger().info('Agent bridge node initialized')

    def publish_sensor_data(self):
        """Publish simulated sensor data."""
        # Create a message with simulated sensor data
        msg = Float32()
        # Simulate temperature sensor reading
        msg.data = 22.5 + random.uniform(-1.5, 1.5)

        # Publish the message
        self.sensor_publisher.publish(msg)

        # Log the published data
        self.get_logger().info(f'Published sensor data: {msg.data:.2f}')

        # Increment the counter
        self.i += 1

    def command_callback(self, msg):
        """Process incoming control commands."""
        self.get_logger().info(f'Received command: {msg.data}')

        # In a real implementation, you would process the command here
        # For now, we just log it
        if msg.data.lower() in ['start', 'stop', 'reset']:
            self.get_logger().info(f'Processing {msg.data.upper()} command')
        else:
            self.get_logger().info(f'Unknown command received: {msg.data}')


def main(args=None):
    """Main function to run the agent bridge."""
    # Initialize rclpy
    rclpy.init(args=args)

    # Create the agent bridge node
    agent_bridge = AgentBridge()

    # Run the node until interrupted
    try:
        rclpy.spin(agent_bridge)
    except KeyboardInterrupt:
        pass
    finally:
        # Clean up
        agent_bridge.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

## Understanding the Code Structure

Let's break down the key components of a typical rclpy node:

### 1. Class Definition
```python
class MyNode(Node):
```
Your node class must inherit from `rclpy.node.Node`.

### 2. Initialization
```python
def __init__(self):
    super().__init__('node_name')
```
The `super().__init__()` call initializes the parent Node class with a unique node name.

### 3. Publishers
```python
self.publisher_ = self.create_publisher(MsgType, 'topic_name', qos_profile)
```
Creates a publisher that sends messages of type `MsgType` to the specified topic.

### 4. Subscribers
```python
self.subscription = self.create_subscription(
    MsgType,
    'topic_name',
    callback_function,
    qos_profile)
```
Creates a subscription that receives messages of type `MsgType` from the specified topic.

### 5. Timers
```python
self.timer = self.create_timer(timer_period, callback_function)
```
Creates a timer that calls the specified callback function at regular intervals.

## Best Practices

When working with rclpy, follow these best practices:

1. **Use type hints and docstrings**: As required by the project constitution
2. **Handle exceptions**: Always include proper error handling
3. **Clean up resources**: Properly destroy nodes and shut down rclpy
4. **Use appropriate QoS profiles**: For different communication requirements
5. **Log important events**: For debugging and monitoring

## Summary

In this section, we've explored how to bridge Python agents to ROS 2 using the rclpy library. We created both publisher and subscriber nodes that demonstrate the fundamental communication patterns in ROS 2. These examples provide a foundation for building more complex Python agents that can interact with the ROS 2 ecosystem.

In the next section, we'll look at URDF (Unified Robot Description Format) and how to interpret robot models.